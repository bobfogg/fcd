Here's the outline of the components of the live tag registration
scheme, and how they communicate.


    +--------+                    +---------+                      +--------+
    |        | <--- setFreq ----- |         | -- startSession1 --> |        |
    | Client |                    |         | <-- sessionToken --- | Motus  |
    | Tuner  |                    |         |                      | Server |
    |        | -- fcdStatus(*) -> |         | --- registerTag ---> |        |
    +--------+                    |         | <--- tagStatus ----  +--------+
     |     ^                      |         |
     | USB |                      | Client  |
     |     |                      | Browser |
     v     |                      |         |
    +---------+                   |         | -- startSession2 --> +--------+
    |         |                   |         | <-sessionStatus(*)-- |        |
    | Funcube | -- audioData(*)-> |         | --- gotFeature(*) -> |  Tag   |
    | dongle  |                   |         | <-- tagStatus(*)---- | Server |
    |         |                   |         | --- endSession ----> |        |
    +---------+                   +---------+                      +--------+

(*): asynchronous

Components:
-----------

Client Tuner: 
   native executable (Win, OS X, linux) with statically linked libusb
   and minimal socket support.  Looks for funcube device, sets
   frequency and other settings via a USB interrupt endpoint on the
   Funcubedongle.  Runs websocket server on port 0xfcd0

Client Browser:
   HTML5-enabled web browser

Motus Server:
    web server on port 80

Tag Server: 
   linux box runs a websocket server on port 0x81a9

Funcubedongle: 
   USB 1.0 Audio device with frequency, gain, and filtering controls
   handled by a USB interrupt endpoint.

API
---

For websocket transactions, request and reply are JSON-formatted objects.

USB: low-level communication between client tuner and funcubedongle using

setFreq Request to ClientTuner

   {
     "freqMHz":  166.38     ## frequency, in MHz
   }

fcdStatus Reply from ClientTuner

   {
     "error":  "",          ## if not empty string, an error message of some kind
                            ## indicating a problem was encountered.
                            ## values so far:
                            ##   "noFCD": no funcubedongle found
                            ##   "fcdBricked": funcubedongle is stuck in bootloader mode
                            ##   "multipleFCD": more than one funcubedongle is plugged in
                            ##   "unknown": some other error condition
     "freqMHz": 166.38,     ## actual frequency funcube was set to 
     "sampRate": 48000      ## sampling rate of funcube, Hz
   }

audioData:
   buffers of stereo 16 bit signed samples.


startSession1 Request to MotusServer
    { 
              ## Maybe nothing?  User is already logged in to be able to access this page.
    }

sessionToken Reply from MotusServer
    {
       "token":  "...",              ## session token; upper-case hex SHA-512 hash of "<tokenTime>,<tokenUser>,<motusPresharedKey>"
       "tokenTime": 1473253222,      ## time used in hash (unix timestamp rounded to second)
       "tokenUser": "denis"          ## username used in hash
    }

startSession2 Request to TagServer
    {
       "command": "startSession",    ## indicate this is the start of a tag finding session
       "token":  "...",              ## \
       "tokenTime": 1473253222,      ##  > these three fields from the sessionToken1 Reply, above
       "tokenUser": "denis",         ## /

       "freqMHz": 166.38,            ## \
                                     ##  > these two fields from the fcdStatus Reply, above
       "sampRate": 48000             ## /
    }

sessionStatus Transfer from TagServer
    {
       "status": "okay"              ## okay if a tag ID session can begin
                                     ## other values:
                                     ##   "alreadyOpen": there's already an ID session with this token; okay to proceed
                                     ##   "tryLater":  too many tag ID sessions are in use; try again later
    }
When the ClientBrowser receives this transfer via websocket,
it can begin the sound processing and sending of gotFeature messages.


gotFeature transfer to TagServer; not really a request, since there's no synchronous response
    {
       "command": "gotFeature",      ## indicate this is a feature detection
       "token": "...",               ## value of token from sessionToken reply above
       "params": {
             "type": "pulse",        ## to allow for future expansion
             "ts": 1467987234.1234,  ## timestamp for feature, with 1/10th millisecond precision
             "plen": 2.5,            ## pulse length, in milliseconds
             "dfreq": 3.456,         ## frequency offset, in kHz
             "sig": -33.4,           ## signal strength, in dB (max)
             "noise": -65.5          ## background noise strength, in dB (max)
       }
    }

tagStatus transfer from TagServer; not really a reply, since it's asynchronous
Several forms; these arrive asynchronously

1.
   {
      "status": "received",          ## confirms pulse was received
      "n": 5                         ## number of pulses seen so far in this session, including this one
   }                               

2. 
   {
      "status": "idOnly",            ## a tag ID has been recognized, but not enough times to estimate repetition period
      "mfgID": 456,                  ## manufacturer's tag ID
      "dfreq": 3.64,                 ## mean frequency offset of pulses in tag burst
      "freqsd": 0.123,               ## SD of frequency offset of pulses in tag burst
      "sig": -33.3,                  ## mean signal strength of pulses in burst (dB max)
      "sigsd": 5                     ## SD of signal strength of pulses in burst (dB)
   }

3. 
   {
      "status": "idPeriod",          ## a tag ID has been recognized, and we have an estimate of period (i.e. burst interval)
      "mfgID": 456,                  ## mfg ID of tag
      "dfreq": 3.64,                 ## mean frequency offset of pulses in tag burst
      "freqsd": 0.123,               ## SD of frequency offset of pulses in tag burst
      "sig": -33.3,                  ## mean signal strength of pulses in burst (dB max)
      "sigsd":                       ## SD of signal strength of pulses in burst (dB)
      "n":  3,                       ## number of bursts of this ID seen
      "period":  6.697,              ## estimate of period
      "periodSD": 0.001,             ## estimate of SD of period
      "param1": 13.7,                ## estimate of parameter 1 (ms)
      "param2": 23.6,                ## estimate of parameter 2 (ms)
      "param3": 33.5,                ## estimate of parameter 3 (ms)
      "param4": 43.4,                ## estimate of parameter 4 (ms)
      "param5": 53.3,                ## estimate of parameter 5 (ms)
      "param6": 63.2,                ## estimate of parameter 6 (ms)
   }

So once an idPeriod message is received that has reasonably low
values for periodSD (i.e. 0.001 or less), the rest of the values
in the tagStatus object can be used in a call to the motus registertag API.


endSession transfer from ClientBrowser to TagServer:

   { 
      "command": "endSession"
   }


Callbacks:
----------
The client browser establishes some callbacks:

  - each time a chunk of audio (time or frequency domain; not sure yet)
    is ready, the browser will call "haveSound".  This will perform
    low-level signal processing, and will send gotFeature objects
    to the Tag Server when appropriate.  The browser can have other
    callbacks installed on this event as well, so that it can e.g.
    display relative signal strength vs. time or something

  - each time the haveSound() callback detects a feature and sends it
    to the Tag Server, it will also call a callback with
    the same JSON object as a parameter.  This callback can be installed
    by calling installHaveSoundCallback(f) where f is a function taking
    a single javascript object as parameter.
    To remove the callback, the Browser can do installHaveSoundCallback(null)

  - the Browser installs its own callback for messages from
    Tag Server websocket.

A simple websockets primer is here:

https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications

Asynchrony
----------

Because the browser will be using websockets to communicate to both
the Client Tuner and the Tag Server, the interaction semantics will be
asynchronous.  i.e. a "request" with object "x" is sent to the target
using:

    ws = new WebSocket("ws://tags.sensorgnome.org");
    ws.onmessage(myHandler);   // handles objects sent back from the target
    ws.send(JSON.stringify(x));

where the handler looks like:

    function myHandler(event e) {
        obj = JSON.parse(e.data);
        ...  // do something according to the semantics of obj from above
    }

So, for example, there's no guarantee that the Tag Server will return
anything after any particular send of a gotFeature object.

This means some reasonable time-outs need to be established:

- setFreq: if no object is received from the Client Tuner via
  websockets within say 3 seconds, there's something wrong.

- gotFeature: if no object is received from the Tag Server within say
  3 seconds of each gotFeature item being sent, there's something
  wrong.

- gotFeature: if no "idOnly" object is received within ~ 40 seconds of
  the first gotFeature item being sent, that's a problem (at least one
  tag ID should have been recognized by then; tag burst intervals are
  always less than 40 seconds, I think)

- gotFeature: if no "idPeriod" object is received within the first ~
  40 seconds of receiving an "idOnly" object, that's also a problem.
  We should have the first estimate of tag period after a pair of
  bursts.





