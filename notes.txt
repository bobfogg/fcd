Using the funcube dongle attached to a beaglebone computer for recording
hits from Lotek telemetry tags.

Issues:

1. DEVICE IDENTITY

- identify which sound device corresponds to which hid device
- on beaglebone Angstrom linux, with funcubes attached to a USB hub,
  the following will work:

  - libhid via libusb returns a path like 0001:000c:02
    where 0001 = bus # of HUB
          000c = device address of an FCD
            02 = control endpoint

         ./fcd -l  # my fcd control utility
    [A]
        These FCDs found:
        enum:  0; serial:      0; path: 0001:000f:02
        enum:  1; serial:      0; path: 0001:000c:02
        enum:  2; serial:      0; path: 0001:0010:02
        enum:  3; serial:      0; path: 0001:000e:02

    Unfortunately, the device addresses are chronologically assigned, and don't
    consistently correspond to physical slots on the hub.

    However (hurray!), we can perform this match as so, assuming a 7-port hub:

        for x in /sys/bus/usb/devices/1-1.[1-7]; do echo -n $x " "; cat $x/devnum; done
    [B]
        /sys/bus/usb/devices/1-1.2  15
        /sys/bus/usb/devices/1-1.5  12
        /sys/bus/usb/devices/1-1.6  13
        /sys/bus/usb/devices/1-1.7  14

    so that, for example, the device in phyiscal slot 5 has been given libusb address 12.
    If the hub has more than 7 ports, the expression [1-7] would need to be changed, to
    e.g. [1-9].  With more than 9 ports, use two or more wildcard expressions:

        for x in /sys/bus/usb/devices/1-1.[1-9] /sys/bus/usb/devices/1-1.1[0-9]; do echo -n $x " "; cat $x/devnum; done

    We still need to associate the sound devices as seen by alsa with these physical 
    devices.  The following will do this:

        ls -lt /dev/snd/by-path/ | sort -k11
    [C]   
        lrwxrwxrwx 1 root root 12 Apr 12 15:43 platform-musb-hdrc.1-usb-0:1.2:1.0 -> ../controlC0
        lrwxrwxrwx 1 root root 12 Apr 12 15:37 platform-musb-hdrc.1-usb-0:1.5:1.0 -> ../controlC1
        lrwxrwxrwx 1 root root 12 Apr 12 16:03 platform-musb-hdrc.1-usb-0:1.6:1.0 -> ../controlC2
        lrwxrwxrwx 1 root root 12 Apr 12 15:37 platform-musb-hdrc.1-usb-0:1.7:1.0 -> ../controlC3

    This list is sorted by the last field (controlCX), and is in the same order as the funcube
    enumeration in [A], as well as the alsa device enumeration obtained as so:

        arecord -l
    [D]
        **** List of CAPTURE Hardware Devices ****
        card 0: V10 [FUNcube Dongle V1.0], device 0: USB Audio [USB Audio]
          Subdevices: 1/1
          Subdevice #0: subdevice #0
        card 1: V10_1 [FUNcube Dongle V1.0], device 0: USB Audio [USB Audio]
          Subdevices: 1/1
          Subdevice #0: subdevice #0
        card 2: V10_2 [FUNcube Dongle V1.0], device 0: USB Audio [USB Audio]
          Subdevices: 1/1
          Subdevice #0: subdevice #0
        card 3: V10_3 [FUNcube Dongle V1.0], device 0: USB Audio [USB Audio]
          Subdevices: 1/1
          Subdevice #0: subdevice #0

    Combining all of this, we can get the physical hub slot for each FCD/Alsa device
    as follows:

        ls -1lt /dev/snd/by-path/ | grep -v '^total' | sort -k11 | gawk -vFS=: 'BEGIN{print "FCD/   Hub\nAlsa   slot"}{a=$3; b=gensub(/^.*controlC/, "", "g", $0); printf " %s      %s\n", b, gensub("^1.", "", "g", a)}'
    
        FCD/   Hub
        Alsa   slot
         0      1
         1      5
         2      7
         3      3

The files funcube.rules and get_fcd_slot_list.sh serve to maintain an active list of hub slot numbers
corresponding to the currently plugged-in fcds.  The slot #s in the file /var/lib/misc/fcd_slot_list
correspond to physical USB ports on a hub, and are in the same order as the funcubes are currently
enumerated by libusb, and hence alsa and libfcd.


2. TIMESTAMPS IN ARECORD OUTPUT

We've modified the aplay/arecord program from alsa-utils-1.0.25 so that it can emit
high precision timestamps into a raw output stream.  This is done by a command line option
--emit-timestamps=N, where N is the number of chunks (internally defined) between timestamps.
The raw output stream will begin with a U32_LE integer giving the chunk size in frames (e.g. 
stereo with 16 bits per sample is a frame size of 4).  Then comes a high precision timestamp
# seconds, # nanoseconds, both unsigned little-endian integers, either 32-bit or 64-bit,
depending on the platform.

Note: on the beaglebone, these timestamps are local time.  On my PC, they appear to be
relative to boot time.  Not sure why, but the beaglebone case is ideal.


3. VAMP REALTIME HOST 

We've modifed the vamp-simple-host application that comes with the VAMP SDK so that it
understands the timestamps embedded in raw streams output by the modified arecord (see 
previous section).  For simplicity, we've used a PluginBufferingAdapter, so that we can
just read the input stream one block at a time, where each block begins with a timestamp,
without worrying about the blocksize requested by the underlying plugin. This will result
in an extra round of copying via a ring buffer, but keeps the code simple.  If performance
becomes an issue, we could instead go back to not using that kind of adapter, and just
make sure that frames_between_timestamps is a multiple of the plugin's blocksize. This
is a pain and can hopefully be avoided.

So, here's how to start recording pulses on the beaglebone:

arecord -r 96000 -f S16_LE -c 2 -t raw --emit-timestamps 1  -D "default:CARD=V10" | vamp-rt-host lotek-plugins.so:findpulsebatch /dev/stdin -o /tmp/fcdout.txt

FIXME 13 April 2012:
- FIXED 25 April [alsa is using CLOCK_MONOTONIC instead of CLOCK_REALTIME for timestamps, so we correct]: pulse timestamps are wonky (why negative?) - 
- fix padding in output? (now that we're not using autosprintf)

TODO 25 April 2012:
- build vamp-rt-host outside of vamp sdk tree
- add an option to read a config file to vamp-rt-host (a file of parameter name value pairs)
- real timestamps are not propagated through Vamp's PluginBufferingAdapter to the plugin from the plugin host.  How should we fix this?  Adjust timestamp returned by plugin, given that it is based on m_frame?  Or make a new RTPluginBufferinAdapter? Or allow timestamps to be spaced by an aribtrary number
of frames, and deal appropriately with that at the frame-advance level on both ends.
- add a header giving timestamp size, endianness, and spacing at start of raw stream
